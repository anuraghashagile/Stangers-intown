
import { createClient } from '@supabase/supabase-js';
import { Message } from '../types';

// Credentials injected for instant deployment
const supabaseUrl = (import.meta as any).env.VITE_SUPABASE_URL || "https://ivvglvpnryiwjdqdsvka.supabase.co";
const supabaseAnonKey = (import.meta as any).env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml2dmdsdnBucnlpd2pkcWRzdmthIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUxMTcxMzEsImV4cCI6MjA4MDY5MzEzMX0.RgQVnTVjptaZTArvv8OvdWxqc7rgnaQaoOhuZH4GtsA";

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn("Supabase credentials missing! Chat will not work.");
}

export const supabase = createClient(
  supabaseUrl,
  supabaseAnonKey,
  {
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
    },
  }
);

/* 
  --- SQL REQUIREMENTS ---
  -- 1. Table for Direct/Offline Messages
  create table if not exists direct_messages (
    id bigint generated by default as identity primary key,
    message_id text not null,
    sender_id text not null,
    receiver_id text not null,
    content text,
    file_data text,
    type text not null,
    is_read boolean default false,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
  );

  -- 2. Table for Persistent Global Chat
  create table if not exists global_messages (
    id bigint generated by default as identity primary key,
    message_id text not null,
    sender_id text,
    sender_name text,
    sender_profile jsonb,
    content text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
  );

  -- 3. Security (Allow public access for this demo)
  alter table direct_messages disable row level security;
  alter table global_messages disable row level security;
*/

export const saveMessageToHistory = async (userId: string, message: Message) => {
  if (message.type !== 'text') return;

  const { error } = await supabase.from('chat_history').insert({
    user_id: userId,
    content: message.text,
    type: message.type,
    sender: message.sender,
    created_at: new Date(message.timestamp).toISOString()
  });

  if (error) console.error("Failed to save history:", error);
};

export const fetchChatHistory = async (userId: string): Promise<Message[]> => {
  const { data, error } = await supabase
    .from('chat_history')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: true })
    .limit(50);

  if (error || !data) return [];

  return data.map((row: any) => ({
    id: row.id.toString(),
    text: row.content,
    type: row.type as 'text',
    sender: row.sender as 'me' | 'stranger' | 'system',
    timestamp: new Date(row.created_at).getTime()
  }));
};

// --- OFFLINE MESSAGING FUNCTIONS ---

export const sendOfflineMessage = async (senderId: string, receiverId: string, message: Message) => {
  // Simple validation to prevent empty inserts
  if (!message.text && !message.fileData) return;

  const { error } = await supabase.from('direct_messages').insert({
    message_id: message.id,
    sender_id: senderId,
    receiver_id: receiverId,
    content: message.text || '',
    file_data: message.fileData || null,
    type: message.type,
    is_read: false,
    created_at: new Date(message.timestamp).toISOString()
  });
  if (error) console.error("Error sending offline message:", error);
};

export const fetchOfflineMessages = async (myPeerId: string) => {
  const { data, error } = await supabase
    .from('direct_messages')
    .select('*')
    .eq('receiver_id', myPeerId)
    .eq('is_read', false);

  if (error) {
     console.error("Error fetching offline messages:", error);
     return [];
  }
  return data;
};

export const markMessageAsRead = async (messageId: string) => {
  await supabase.from('direct_messages').update({ is_read: true }).eq('message_id', messageId);
};

// --- PERSISTENT GLOBAL CHAT ---

export const sendPersistentGlobalMessage = async (message: Message) => {
  if (!message.text) return;
  
  await supabase.from('global_messages').insert({
    message_id: message.id,
    sender_id: message.senderPeerId,
    sender_name: message.senderName,
    sender_profile: message.senderProfile,
    content: message.text,
    created_at: new Date(message.timestamp).toISOString()
  });
};

export const fetchRecentGlobalMessages = async (): Promise<Message[]> => {
  const { data, error } = await supabase
    .from('global_messages')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(60); // Increased limit slightly

  if (error || !data) {
     console.error("Fetch Global Chat Error:", error);
     return [];
  }

  // Reverse to show oldest first
  return data.reverse().map((row: any) => ({
    id: row.message_id,
    text: row.content,
    sender: 'stranger',
    senderName: row.sender_name,
    senderPeerId: row.sender_id,
    senderProfile: row.sender_profile,
    timestamp: new Date(row.created_at).getTime(),
    type: 'text'
  }));
};
